# Metrics schemas

Schemas serve to interpret the output (JSON) of a [metrics source](metric-sources.md) and convert it to [metrics](metrics.md) that can be understood by the application. 

Each source needs at least one schema. More than one schema can be associated to a source and one schema can be associated to one or more sources.

Metrics generated by each schema will have an attribute with key "$schema" and value the ID of the schema.

There are two ways of defining a schema:
* At the source configuration: in case all the data comes with the same structure you just apply one schema in the source. 
Schema ID does not need to be specified. Metric will contain an $schema attribute with the same ID as the source.
This configuration cannot be updated while running.
* Later in the configuration file with metrics.schema.schema-id prefix: in case the source consumes metrics with different schemas. 
You can defined several schemas for the same source (for each of the incoming metric types). 
If same type/schema come from several of your sources, you can apply an schema to several of them.
This configuration can be updated while running.   

In any case, you can apply a [metrics filter](metrics-filter.md). This way you make sure that the schema is applied to the metrics that the schema should be concerned of (a certain incoming type).
NOTE: filter is applied after parsing, so it can only be applied to the attributes that are parsed in the schema. If you want to filter on attributes that are not parsed, you need to parse them. 

For both cases, the configuration parameters are the following:

```
metrics.schema.<schema-id>.sources = <space-separated-source-ids>
metrics.schema.<schema-id>.timestamp.key = <attribute that represent the time>
metrics.schema.<schema-id>.timestamp.format = <timestamp_format> (default: yyyy-MM-dd'T'HH:mm:ssZ)
metrics.schema.<schema-id>.attributes = <attributs separated by comma to extract from the JSON>
metrics.schema.<schema-id>.attributes.<alias-1> = <key-to-attribute-1>
metrics.schema.<schema-id>.attributes.<alias-2> = <key-to-attribute-2>
metrics.schema.<schema-id>.attributes.<alias-n> = <key-to-attribute-n>
metrics.schema.<schema-id>.value.keys = <attributes that represent values>
metrics.schema.<schema-id>.value.keys.<alias-1> = <key-to-value-1>
metrics.schema.<schema-id>.value.keys.<alias-2> = <key-to-value-2>
metrics.schema.<schema-id>.value.keys.<alias-n> = <key-to-value-n>
metrics.schema.<schema-id>.filter.<configs at Metrics filter> = <values>
```

For configuring the schema in the source, you replace metrics.schema.schema-id by metrics.source.source-id.schema.

"timestamp.key" indicates the key in the JSON document that contains the timestamp for the metric. If the JSON document does not contain the timestamp value, no metric will be generated. 

"timestamp.format" indicates the format of the timestamp stored in the attribute configured by "timestamp.attribute". If the format is a number that represents epoch in milliseconds, it must be set to "epoch-ms", if seconds "epoch-s". If the JSON document contains a timestamp with wrong format, metric with exception value will be generated, setting the timestamp to current time. 

"attributes" configure the keys that will be extracted from the JSON document. You can indicate a list of keys separated by space.
You can also configure these attributes individually assigning aliases. Assigned alias will be used to refer to the attribute in any metric filter. 
List of keys or aliases can be combined.
If the JSON document does not contain the attribute, the metric will not contain such attribute.

"value.keys" configure the keys from which metric values will be extracted from the JSON document. You can indicate a list of keys separated by space. A metric will be created for each key, all metrics generated from the same JSON document will share the same timestamp and attributes. All generated metrics will contain an extra attribute with name "$value\_attribute", its value indicates the key (or alias) from which the value has been extracted. 
You can also configure these attributes for values individually assigning aliases. Assigned alias will be stored at "$value\_attribute", so the alias will be used in any metric filter.
List of keys or aliases can be combined.
If JSON document does not contain the value, the metric will not be generated.
Type of generated metrics will be determined by the corresponding JSON type: string, float or boolean.

Commonly, you can face two different scenarios. One where each incoming JSON represent a single metric, an example of JSON document could be: 

```
{
	"headers":{
		"TIMESTAMP": "2017-11-01T10:29:14+02:00",
		"type": "CPUUsage",
		"hostname": "host-1234.cern.ch"
	},"body":{
		"metric":{
			"value": 295.13
		}
	}
}
```

For this kind of documents, the configuration would looks like the following.

```
metrics.schema.<schema-id>.timestamp.key = header.TIMESTAMP

metrics.schema.<schema-id>.attributes = headers.type headers.hostname
# or/and with aliases
metrics.schema.<schema-id>.attributes.type = headers.type
metrics.schema.<schema-id>.attributes.hostname = headers.hostname

metrics.schema.<schema-id>.value.keys = body.metric.value
# or/and with aliases
metrics.schema.<schema-id>.value.keys.value_float = body.metric.value
```

One metric will be generated per JSON document. The metric timestamp will be "2017-11-01T10:29:14+02:00" and the value 295.13. If not using aliases, metric will have the following attributes:
* headers.type = "CPUUsage"
* headers.hostname = "host-1234.cern.ch"
* $value\_attribute = "body.metric.value"

If aliases are used:
* type = "CPUUsage"
* hostname = "host-1234.cern.ch"
* $value\_attribute = "value\_float"

A different scenario is when a single document contains several metrics, an example of JSON document could be:

```
{
	"headers":{
		"TIMESTAMP": "2017-11-01T10:29:14+02:00",
		"hostname": "host-1234.cern.ch"
	},"body":{
		"CPUUsage": 295.13,
		"IsWriteActive": true,
		"CPUName": "Intel Core i8"
	}
}
```

For this kind of documents, the configuration would looks like the following.

```
metrics.schema.<schema-id>.timestamp.keys = header.TIMESTAMP

metrics.schema.<schema-id>.attributes = headers.hostname
# or/and with aliases
metrics.schema.<schema-id>.attributes.hostname = headers.hostname

metrics.schema.<schema-id>.value.keys = body.CPUUsage body.MemoryUsage body.WriteBytesPerSecond body.ReadBytesPerSecond
# or/and with aliases
metrics.schema.<schema-id>.value.keys.CPUUsage = body.CPUUsage
metrics.schema.<schema-id>.value.keys.WriteBytesPerSecond = body.WriteBytesPerSecond
metrics.schema.<schema-id>.value.keys.ReadBytesPerSecond = body.ReadBytesPerSecond
```

In this case, three metrics will be generated per JSON document (as many as attributes for values). Generated metrics will be (if aliases are not used):
* Metric with timestamp "2017-11-01T10:29:14+02:00", value 295.13 and attributes:
  * headers.hostname = "host-1234.cern.ch"
  * $value\_attribute = "body.CPUUsage"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value true and attributes:
  * headers.hostname = "host-1234.cern.ch"
  * $value\_attribute = "body.IsWriteActive"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value "Intel Core i8" and attributes:
  * headers.hostname = "host-1234.cern.ch"
  * $value\_attribute = "body.CPUName"

If aliases are used:
* Metric with timestamp "2017-11-01T10:29:14+02:00", value 295.13 and attributes:
  * hostname = "host-1234.cern.ch"
  * $value\_attribute = "CPUUsage"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value true and attributes:
  * hostname = "host-1234.cern.ch"
  * $value\_attribute = "IsWriteActive"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value "Intel Core i8" and attributes:
  * hostname = "host-1234.cern.ch"
  * $value\_attribute = "CPUName"